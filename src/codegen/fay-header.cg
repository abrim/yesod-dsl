module ~{moduleName m}Fay where

data Module = Module {
    modEntities  :: [Entity],
    modClasses   :: [Class],
    modEnums     :: [EnumType],
    modRoutes    :: [Route]
} deriving (Show)

type ClassName = String
type ParamName = String
type EntityName = String
type EnumName = String

data FieldType = FTWord32 | FTWord64 | FTInt32 | FTInt64 | FTText 
               | FTBool | FTDouble | FTTimeOfDay | FTDay | FTUTCTime 
               | FTZonedTime deriving (Eq)


type FieldName = String 
type PathName = String



data HandlerType = GetHandler 
                 | PutHandler 
                 | PostHandler 
                 | DeleteHandler 
                 deriving (Eq) 

data Handler = Handler {
    handlerType   :: HandlerType
} deriving (Eq)

data Entity = Entity {
    entityName       :: String,
    entityInstances  :: [ClassName],
    entityFields     :: [Field],
    entityChecks     :: [FunctionName]    
} deriving (Eq)

data Route = Route {
    routePath :: [PathPiece],
    routeHandlers :: [Handler]
} deriving (Eq)

routePathParams :: Route -> [PathPiece]
routePathParams = (filter isPathParam) . routePath
    where isPathParam (PathId _) = True
          isPathParam _ = False    

handlerName :: Route -> Handler -> String
handlerName r h = routeName (routePath r) ++ " " ++ show (handlerType h)

routeName :: [PathPiece] -> String
routeName ps = "/" ++ intercalate "/" (map show ps)

data PathPiece = PathText String
               | PathId EntityName
               deriving (Eq)
instance Show PathPiece where
    show (PathText s) = s
    show (PathId en) = "#" ++ en ++ "Id"
    

entityFieldByName :: Entity -> FieldName -> Field
entityFieldByName e fn = maybe (error $ "No field " ++ fn ++ " in " ++ entityName e) id
                               (find (\f -> fieldName f == fn) (entityFields e))

data EnumType = EnumType {
    enumName :: String,
    enumValues :: [String]
} deriving (Show, Eq)

data Class = Class {
    className    :: String,
    classFields  :: [Field]
} deriving (Show, Eq)

type DefaultValue = String
type IsListFlag = Bool

data FieldContent = NormalField FieldType [FieldOption]
                    | EntityField EntityName 
                    | EnumField EnumName
                deriving (Show,Eq)
  

data Field = Field {
    fieldOptional :: Bool,
    fieldName     :: FieldName,
    fieldContent  :: FieldContent
} deriving (Show,Eq)

type FunctionName = String
data FieldOption = FieldDefault FieldValue
                 | FieldCheck FunctionName
                 deriving (Show, Eq)

data FieldValue = StringValue String
                | IntValue Int
                | FloatValue Double
                | BoolValue Bool
                | NothingValue
                deriving (Eq)

reflection :: Module
reflection = Module {
    modEntities = [
~{indent 8 $ intercalate ",\n" (map trEntity (modEntities m))}        
    ],
    modClasses = [
~{indent 8 $ intercalate ",\n" (map trClass (modClasses m))}        
    ],
    modEnums = [
~{indent 8 $ intercalate ",\n" (map trEnum (modEnums m))}        
    ],
    modRoutes = [
~{indent 8 $ intercalate ",\n" (map trRoute (modRoutes m))}
    ]
}

