# yesod-generate-rest

A domain specific language and a code generator desined to create RESTful
JSON-only web services for managing a database with [Yesod web framework](http://www.yesodweb.com/)
and [Persistent](http://www.yesodweb.com/book/persistent).

This code generator borrowes some code from
[yesod-generate](http://github.com/maxcan/yesod-generate/). The original
yesod-generate supports also non-JSON web services. 

## Features
 * splitting database definitions into multiple files
 * generates support code for implementing polymorphic relations and accessing common fields
 * generates boilerplate code for entity validation
 * supports following field types : Word32, Word64, Int32, Int64, Text, Bool, Double, TimeOfDay, Day, UTCTime, ZonedTime
 * generates RESTful JSON web service for managing entities 
 * hooks to user-supplied pre and post service hooks (e.g. checking if user is allowed to retrieve a particular record, or logging changes)
 * can generate filtering and sorting code compatible with ExtJS grids

## License
 * The code generator is distributed under the terms of [Simplified BSD license](LICENSE)

## Quick start

### Step 1: get the source code and compile

    git clone git://github.com/tlaitinen/yesod-generate-rest.git
    cd yesod-generate-rest
    make

### Step 2: Create scaffolded Yesod site

    yesod init

### Step 3: write database and service definition file
```
-- other files can be included for increased modularity
-- import "module.def";

-- class defines a set of fields that can be inherited by an entity
class Named {
    name Text check nonempty;
}

class Versioned {
    version Maybe Int64; 
}

-- User-entity is an instance of the classes Named and Versioned
entity Person : Named, Versioned {
    language Text check validLanguage;
    timezone Text check validTimezone;

    -- service definitions start here
    get { 
        -- GET service does not require authentication
        public;

        -- pre-hooks can be used to check if a particular
        -- record can be retrieved
        pre-hook personGetAllowed;

        -- post-hooks are run at the end of the handler
        post-hook logPersonGet;

        -- ExtJS compatible filtering and sorting parameters
        -- can be generated by including the following keyword
        default-filter-sort; 

        -- additional user-supplied filtering and sorting functions can be added
        filter filterPersons;
        select-opts sortPersons;
    }
    post {}
    delete {}
    put {}
    validate {
        -- validate is like post-handler but does not 
        -- insert the entity to database
    }
}

entity Note : Named, Versioned {
    owner   Person;
    body    Text;
    created DateTime;
    get { 
    }
    post {}
    delete {}
    put {}
    validate {}
}

entity FileItem : Named {
    owner Person;
    path Text;

    -- uniqueness definitions are supported
    unique OwnerName owner name;

    -- entity-wide check functions can be added, too
    check validFileItem;
}

entity ChangeRecord {
    field    Text;
    oldValue Text;
    newValue Text;
    time     DateTime;
    version  Int64;

    -- a polymorphic relation which will be expanded to a number of fields
    -- pointing a each possible entity that is an instance of Versioned
    'entity' Maybe Versioned;
}
```

### Step 4: run code generator

    $ yesod-generate-rest main.def

At the moment, the code generator synchronizes the definitions to the files config/models, config/routes, Model/Json.hs, Model/Validation.hs, Model/Classes.hs, and Handler/Generated.hs .

#### config/models
```
User
    ident Text
    password Text Maybe
    UniqueUser ident
Email
    email Text
    user UserId Maybe
    verkey Text Maybe
    UniqueEmail email

 -- By default this file is used in Model.hs (which is imported by Foundation.hs)
-- LINES BELOW GENERATED BY yesod-generated-rest --
ChangeRecord json
    entityNote NoteId Maybe 
    entityPerson PersonId Maybe 
    version Int64 
    time UTCTime 
    newValue Text 
    oldValue Text 
    field Text 

FileItem json
    path Text 
    owner PersonId 
    name Text 
    UniqueOwnerName owner name

Note json
    created UTCTime 
    body Text 
    owner PersonId 
    version Int64 Maybe 
    name Text 

Person json
    timezone Text 
    language Text 
    version Int64 Maybe 
    name Text 
```

#### config/routes
```
/static StaticR Static getStatic
/auth   AuthR   Auth   getAuth

/favicon.ico FaviconR GET
/robots.txt RobotsR GET

/ HomeR GET POST
-- LINES BELOW GENERATED BY yesod-generated-rest --
/data/note NoteManyR GET POST
/data/note/#NoteId NoteR GET PUT DELETE
/validate/note NoteValidateR POST
/data/person PersonManyR GET POST
/data/person/#PersonId PersonR GET PUT DELETE
/validate/person PersonValidateR POST
```

#### Model/Validation.hs
```haskell
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExistentialQuantification #-}
module Model.Validation (Validatable(..)) where
import Data.Text
import qualified Model.ValidationFunctions as V
import Import
checkResult :: forall (m :: * -> *). (Monad m) => Text -> m Bool -> m Text
checkResult msg f = do
   result <- f
   return $ if result then "" else msg

class Validatable a where
    validate :: forall m. (PersistQuery m, PersistEntityBackend a ~ PersistMonadBackend m) => a -> m [Text]
instance Validatable ChangeRecord where 
    validate e = sequence [
        ]

instance Validatable FileItem where 
    validate e = sequence [
        checkResult "FileItem.name nonempty" (V.nonempty $ fileItemName e),
        checkResult "FileItem validFileItem" (V.validFileItem e)
        ]

instance Validatable Note where 
    validate e = sequence [
        checkResult "Note.name nonempty" (V.nonempty $ noteName e)
        ]

instance Validatable Person where 
    validate e = sequence [
        checkResult "Person.timezone validTimezone" (V.validTimezone $ personTimezone e),
        checkResult "Person.language validLanguage" (V.validLanguage $ personLanguage e),
        checkResult "Person.name nonempty" (V.nonempty $ personName e)
        ]
```

#### Model/Classes.hs
```haskell
module Model.Classes where
import Import
import Data.Int
import Data.Word
import Data.Time
class Versioned a where
    versionedVersion :: a -> Maybe Int64

instance Versioned Note where 
    versionedVersion = noteVersion

instance Versioned Person where 
    versionedVersion = personVersion

class Named a where
    namedName :: a -> Text

instance Named FileItem where 
    namedName = fileItemName

instance Named Note where 
    namedName = noteName

instance Named Person where 
    namedName = personName
```

#### Model/Json.hs

```haskell
{-# LANGUAGE FlexibleInstances #-}
module Model.Json where
import Import
import Data.Aeson
import qualified Data.HashMap.Lazy as HML
instance ToJSON (Entity ChangeRecord) where
    toJSON (Entity k v) = case toJSON v of
        Object o -> Object $ HML.insert "id" (toJSON k) o
        _ -> error "unexpected JS encode error"
instance ToJSON (Entity FileItem) where
    toJSON (Entity k v) = case toJSON v of
        Object o -> Object $ HML.insert "id" (toJSON k) o
        _ -> error "unexpected JS encode error"
instance ToJSON (Entity Note) where
    toJSON (Entity k v) = case toJSON v of
        Object o -> Object $ HML.insert "id" (toJSON k) o
        _ -> error "unexpected JS encode error"
instance ToJSON (Entity Person) where
    toJSON (Entity k v) = case toJSON v of
        Object o -> Object $ HML.insert "id" (toJSON k) o
        _ -> error "unexpected JS encode error"
```

#### Handler/Generated.hs
```haskell
{-# LANGUAGE RankNTypes #-}
module Handler.Generated (
    postNoteValidateR,
    putNoteR,
    deleteNoteR,
    postNoteManyR,
    getNoteManyR,
    getNoteR,
    postPersonValidateR,
    putPersonR,
    deletePersonR,
    postPersonManyR,
    getPersonManyR,
    getPersonR
) where 
import Import
import Yesod.Auth
import Model.Validation
import Model.Json ()
import Data.Aeson ((.:), (.:?), (.!=), FromJSON, parseJSON, decode)
import Data.Aeson.TH
import Data.Text.Encoding (encodeUtf8)
import qualified Data.ByteString.Lazy as LBS
import Data.Maybe
import qualified Data.Text.Read
import Data.Aeson.Types (emptyObject)
import qualified Handler.Hooks as H
import qualified Data.Text as T
import Control.Monad (mzero)

data FilterJsonMsg = FilterJsonMsg {
    filterJsonMsg_type :: Text,
    filterJsonMsg_value :: Text,
    filterJsonMsg_field :: Text,
    filterJsonMsg_comparison :: Text
}
instance FromJSON FilterJsonMsg where
     parseJSON (Object v) = FilterJsonMsg <$>
           v .: "type" <*>
           v .: "value" <*>
           v .: "field" <*>
           v .:? "comparison" .!= "eq"
     parseJSON _ = mzero
data SortJsonMsg = SortJsonMsg {
    sortJsonMsg_property :: Text,
    sortJsonMsg_direction :: Text
}
$(deriveJSON (drop 12) ''SortJsonMsg)
defaultFilterOp :: forall v typ. PersistField typ => Text -> EntityField v typ -> typ -> Filter v
defaultFilterOp "eq" = (==.)
defaultFilterOp "neq" = (!=.)
defaultFilterOp "lt" = (<.)
defaultFilterOp "gt" = (>.)
defaultFilterOp "le" = (<=.)
defaultFilterOp "ge" = (>=.)
defaultFilterOp _ = (==.)
parseValue :: Read a => Text -> Maybe a
parseValue s = case (reads $ T.unpack s) of
   [(v,_)] -> Just v
   _ -> Nothing
getRangeSelectOpts :: forall s m v. GHandler s m [SelectOpt v]
getRangeSelectOpts = do
    start <- lookupGetParam "start"
    limit <- lookupGetParam "limit"
    return $ mkOpts (parseInt start) (parseInt limit)
        where
            parseInt (Just s) = case (Data.Text.Read.decimal s) of
              Right (x,_) -> Just x
              _ -> Nothing
            parseInt _ = Nothing
            mkOpts (Just s) (Just l) = [ OffsetBy s, LimitTo l ]
            mkOpts _ _ = []

postNoteValidateR :: Handler RepJson
postNoteValidateR = do
    entity <- parseJsonBody_ 
    _ <- requireAuthId
    errors <- runDB $ validate (entity :: Note)
    if null errors
        then do
            jsonToRepJson $ emptyObject
        else jsonToRepJson $ object [ "errors" .= toJSON errors ]

putNoteR :: NoteId -> Handler RepJson
putNoteR key = do
    entity <- parseJsonBody_
    _ <- requireAuthId
    errors <- runDB $ validate (entity :: Note)
    if null errors
        then do
            runDB $ repsert key entity
            jsonToRepJson $ emptyObject
        else jsonToRepJson $ object [ "errors" .= toJSON errors ]

deleteNoteR :: NoteId -> Handler RepJson
deleteNoteR key = do
    _ <- requireAuthId
    runDB $ delete key
    jsonToRepJson $ emptyObject

postNoteManyR :: Handler RepJson
postNoteManyR = do
    entity <- parseJsonBody_
    _ <- requireAuthId
    errors <- runDB $ validate (entity :: Note)
    if null errors
        then do
            key <- runDB $ insert (entity :: Note)
            jsonToRepJson $ object [ "id" .= toJSON key ]
        else jsonToRepJson $ object [ "errors" .= toJSON errors ]
getNoteManyR :: Handler RepJson
getNoteManyR = do
    _ <- requireAuthId
    let filters = [] :: [[Filter Note]]
    let selectOpts = [] :: [[SelectOpt Note]]
    entities <- runDB $ selectList (concat filters) (concat selectOpts)
    jsonToRepJson $ object [ "entities" .= toJSON entities ] 

getNoteR :: NoteId -> Handler RepJson
getNoteR key = do
    _ <- requireAuthId
    entity <- runDB $ get key
    jsonToRepJson $ toJSON entity

postPersonValidateR :: Handler RepJson
postPersonValidateR = do
    entity <- parseJsonBody_ 
    _ <- requireAuthId
    errors <- runDB $ validate (entity :: Person)
    if null errors
        then do
            jsonToRepJson $ emptyObject
        else jsonToRepJson $ object [ "errors" .= toJSON errors ]

putPersonR :: PersonId -> Handler RepJson
putPersonR key = do
    entity <- parseJsonBody_
    _ <- requireAuthId
    errors <- runDB $ validate (entity :: Person)
    if null errors
        then do
            runDB $ repsert key entity
            jsonToRepJson $ emptyObject
        else jsonToRepJson $ object [ "errors" .= toJSON errors ]

deletePersonR :: PersonId -> Handler RepJson
deletePersonR key = do
    _ <- requireAuthId
    runDB $ delete key
    jsonToRepJson $ emptyObject

postPersonManyR :: Handler RepJson
postPersonManyR = do
    entity <- parseJsonBody_
    _ <- requireAuthId
    errors <- runDB $ validate (entity :: Person)
    if null errors
        then do
            key <- runDB $ insert (entity :: Person)
            jsonToRepJson $ object [ "id" .= toJSON key ]
        else jsonToRepJson $ object [ "errors" .= toJSON errors ]
toDefaultFilterPerson :: FilterJsonMsg -> Maybe (Filter Person)
toDefaultFilterPerson f = case (filterJsonMsg_field f) of
    "timezone" -> case (parseValue $ filterJsonMsg_value f) of (Just v) -> Just $ defaultFilterOp  (filterJsonMsg_comparison f) PersonTimezone v ; _ -> Nothing
    "language" -> case (parseValue $ filterJsonMsg_value f) of (Just v) -> Just $ defaultFilterOp  (filterJsonMsg_comparison f) PersonLanguage v ; _ -> Nothing
    "version" -> case (parseValue $ filterJsonMsg_value f) of (Just v) -> Just $ defaultFilterOp  (filterJsonMsg_comparison f) PersonVersion (Just v) ; _ -> Nothing
    "name" -> case (parseValue $ filterJsonMsg_value f) of (Just v) -> Just $ defaultFilterOp  (filterJsonMsg_comparison f) PersonName v ; _ -> Nothing
    _ -> Nothing
toDefaultSortPerson :: SortJsonMsg -> Maybe (SelectOpt Person)
toDefaultSortPerson s = case (sortJsonMsg_property s) of
    "timezone" -> case (sortJsonMsg_direction s) of "ASC" -> Just $ Asc PersonTimezone; "DESC" -> Just $ Desc PersonTimezone; _ -> Nothing
    "language" -> case (sortJsonMsg_direction s) of "ASC" -> Just $ Asc PersonLanguage; "DESC" -> Just $ Desc PersonLanguage; _ -> Nothing
    "version" -> case (sortJsonMsg_direction s) of "ASC" -> Just $ Asc PersonVersion; "DESC" -> Just $ Desc PersonVersion; _ -> Nothing
    "name" -> case (sortJsonMsg_direction s) of "ASC" -> Just $ Asc PersonName; "DESC" -> Just $ Desc PersonName; _ -> Nothing
    _ -> Nothing
getPersonManyR :: Handler RepJson
getPersonManyR = do
    filters <- sequence [
        H.filterPersons
        ,
        do
            f <- lookupGetParam "filter"
            let f' = (maybe Nothing (decode . LBS.fromChunks . (:[]) . encodeUtf8) f) :: Maybe [FilterJsonMsg]
            return $ maybe [] (mapMaybe toDefaultFilterPerson) f'
        ]
    selectOpts <- sequence [
        H.sortPersons
        ,
        do
            s <- lookupGetParam "sort"
            rangeOpts <- getRangeSelectOpts
            let s' = (maybe Nothing (decode . LBS.fromChunks .(:[]) . encodeUtf8) s) :: Maybe [SortJsonMsg]
            return $ maybe [] (mapMaybe toDefaultSortPerson) s' ++ rangeOpts
        ]
    entities <- runDB $ selectList (concat filters) (concat selectOpts)
    sequence_ [H.logPersonGet entities]
    jsonToRepJson $ object [ "entities" .= toJSON entities ] 

getPersonR :: PersonId -> Handler RepJson
getPersonR key = do
    entity <- runDB $ get key
    errors <- sequence [H.personGetAllowed entity]
    if null errors
        then do
            sequence_ [H.logPersonGet key entity]
            jsonToRepJson $ toJSON entity
        else jsonToRepJson $ object [ "errors" .= toJSON errors ]
```

